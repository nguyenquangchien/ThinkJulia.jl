[[chap19]]
== Nh·ªØng m·∫∑t t·ªët: c√∫ ph√°p

M·ªôt trong nh·ªØng m·ª•c ti√™u c·ªßa t√¥i khi vi·∫øt s√°ch n√†y l√† d·∫°y b·∫°n √≠t Julia nh·∫•t khi c√≥ th·ªÉ. Khi ph·∫£i ƒë·ª©ng tr∆∞·ªõc hai l·ª±a ch·ªçn gi·∫£i quy·∫øt v·∫•n ƒë·ªÅ, t√¥i ch·ªçn m·ªôt c√°ch v√† tr√°nh ƒë·ªÅ c·∫≠p ƒë·∫øn c√°ch kia. Ho·∫∑c ƒë√¥i khi t√¥i ƒë∆∞a c√°ch th·ª© hai v√†o m·ªôt b√†i t·∫≠p.

B√¢y gi·ªù t√¥i mu·ªën tr·ªü l·∫°i v√†i ƒë·∫∑c ƒëi·ªÉm hay m√† t√¥i ƒë√£ b·ªè qua tr∆∞·ªõc ƒë√¢y. Julia cung c·∫•p nhi·ªÅu t√≠nh nƒÉng m√† th·ª±c ra ch∆∞a c·∫ßn thi·∫øt ‚Äîkh√¥ng c√≥ ch√∫ng b·∫°n v·∫´n c√≥ th·ªÉ vi·∫øt m√£ l·ªánh ƒë·∫πp‚Äînh∆∞ng d√πng ch√∫ng th√¨ ƒë√¥i khi c√≥ th·ªÉ vi·∫øt ƒë∆∞·ª£c m√£ l·ªánh ng·∫Øn g·ªçn, d·ªÖ ƒë·ªçc ho·∫∑c hi·ªáu qu·∫£ h∆°n, v√† ƒë√¥i khi ƒë∆∞·ª£c c·∫£ ba ƒëi·ªÅu n√†y.

·ªû ch∆∞∆°ng n√†y v√† ch∆∞∆°ng t·ªõi, ta th·∫£o lu·∫≠n nh·ªØng v·∫•n ƒë·ªÅ t√¥i ƒë√£ b·ªè qua trong c√°c ch∆∞∆°ng tr∆∞·ªõc:

* b·ªï sung c√∫ ph√°p
* c√°c h√†m, ki·ªÉu d·ªØ li·ªáu v√† macro c√≥ ngay trong +Base+
(((Base)))
* c√°c h√†m, ki·ªÉu d·ªØ li·ªáu v√† macro c√≥ trong
(((Standard Library)))

=== C√°c c·∫∑p ƒë∆∞·ª£c ƒë·∫∑t t√™n 

B·∫°n c√≥ th·ªÉ ƒë·∫∑t t√™n c√°c th√†nh ph·∫ßn c·ªßa m·ªôt c·∫∑p, b·∫±ng c√°ch n√†y t·∫°o m·ªôt c·∫∑p ƒë∆∞·ª£c ƒë·∫∑t t√™n:

[source,@julia-repl-test]
----
julia> x = (a=1, b=1+1)
(a = 1, b = 2)
julia> x.a
1
----

V·ªõi c·∫∑p ƒë∆∞·ª£c ƒë·∫∑t t√™n, c√°c tr∆∞·ªùng c√≥ th·ªÉ truy c·∫≠p theo t√™n b·∫±ng c√∫ ph√°p d·∫•u ch·∫•m +(x.a)+.
(((c·∫∑p ƒë∆∞·ª£c ƒë·∫∑t t√™n)))(((c√∫ ph√°p d·∫•u ch·∫•m)))


=== H√†m

Trong Julia, h√†m c√≥ th·ªÉ ƒë∆∞·ª£c ƒë·ªãnh nghƒ©a b·∫±ng c√∫ ph√°p ng·∫Øn g·ªçn.

[source,@julia-repl-test]
----
julia> f(x,y) = x + y
f (generic function with 1 method)
----

[[anonymous_functions]]
==== H√†m khuy·∫øt danh

Ta c√≥ th·ªÉ ƒë·ªãnh nghƒ©a m·ªôt h√†m m√† kh√¥ng quy ƒë·ªãnh t√™n cho n√≥:

[source,@julia-repl-test]
----
julia> x -> x^2 + 2x - 1
#1 (generic function with 1 method)
julia> function (x)
           x^2 + 2x - 1
       end
#3 (generic function with 1 method)
----

ƒê√¢y l√† nh·ªØng v√≠ d·ª• _h√†m khuy·∫øt danh_. Ta th∆∞·ªùng d√πng h√†m khuy·∫øt danh l√†m ƒë·ªëi s·ªë cho m·ªôt h√†m kh√°c:
(((anonymous function)))(((Plots)))((("module", "Plots", see="Plots")))(((plot)))((("function", "Plots", "plot", see="plot")))

[source,jlcon]
----
julia> using Plots

julia> plot(x -> x^2 + 2x - 1, 0, 10, xlabel="x", ylabel="y")

----

<<fig19-1>> cho th·∫•y k·∫øt qu·∫£ c·ªßa l·ªánh v·∫Ω bi·ªÉu ƒë·ªì.

[[fig19-1]]
.Plot
image::images/fig191.svg[pdfwidth="10cm"]

==== ƒê·ªëi s·ªë t·ª´ kh√≥a

C≈©ng c√≥ th·ªÉ ƒë·∫∑t t√™n c√°c ƒë·ªëi s·ªë c·ªßa h√†m:

[source,@julia-repl-test]
----
julia> function myplot(x, y; style="solid", width=1, color="black")
           ###
       end
myplot (generic function with 1 method)
julia> myplot(0:10, 0:10, style="dotted", color="blue")

----

_Keyword arguments_ in a function are specified after a semicolon in the signature but can be called with a comma.
(((;)))(((keyword arguments)))

==== Bao ƒë√≥ng (closure)

_Bao ƒë√≥ng_ (closure) l√† kƒ© thu·∫≠t cho ph√©p m·ªôt h√†m n·∫Øm b·∫Øt ƒë∆∞·ª£c m·ªôt bi·∫øn ƒë√£ ƒë·ªãnh nghƒ©a b√™n ngo√†i ph·∫°m vi g·ªçi c·ªßa h√†m ƒë√≥.

[source,@julia-repl-test]
----
julia> foo(x) = ()->x
foo (generic function with 1 method)

julia> bar = foo(1)
#1 (generic function with 1 method)

julia> bar()
1
----

·ªû v√≠ d·ª• n√†y, h√†m +foo+ tr·∫£ l·∫°i m·ªôt h√†m khuy·∫øt danh truy c·∫≠p t·ªõi ƒë·ªëi s·ªë +x+ c·ªßa h√†m +foo+. +bar+ ch·ªâ ƒë·∫øn h√†m khuy·∫øt danh v√† tr·∫£ l·∫°i gi√° tr·ªã ƒë·ªëi s·ªë c·ªßa +foo+.


=== Kh·ªëi l·ªánh

_Kh·ªëi l·ªánh_ l√† m·ªôt c√°ch ƒë·ªÉ nh√≥m nhi·ªÅu c√¢u l·ªánh v·ªõi nhau. Kh·ªëi b·∫Øt ƒë·∫ßu b·∫±ng t·ª´ kh√≥a +begin+ v√† k·∫øt th√∫c v·ªõi +end+.
(((begin)))((("keyword", "begin", see="begin")))(((end)))(((block)))

·ªû <<chap04>> ta ƒë√£ gi·ªõi thi·ªáu macro +@svg+:

[source,julia]
----
üê¢ = Turtle()
@svg begin
    forward(üê¢, 100)
    turn(üê¢, -90)
    forward(üê¢, 100)
end
----

·ªû v√≠ d·ª• n√†y, macro +@svg+ ch·ªâ c√≥ m·ªôt ƒë·ªëi s·ªë, t·ª©c l√† m·ªôt kh·ªëi nh√≥m 3 l·ªùi g·ªçi h√†m l·∫°i.

==== Kh·ªëi +let+

M·ªôt kh·ªëi +let+ r·∫•t h·ª©u √≠ch khi ta mu·ªën t·∫°o ra "binding", nghƒ©a l√† nh·ªØng v·ªã tr√≠ c√≥ th·ªÉ tham chi·∫øu t·ªõi c√°c gi√° tr·ªã.

[source,@julia-repl-test]
----
julia> x, y, z = -1, -1, -1;

julia> let x = 1, z
           @show x y z;
       end
x = 1
y = -1
ERROR: UndefVarError: z not defined
julia> @show x y z;
x = -1
y = -1
z = -1
----

·ªû v√≠ d·ª• n√†y, macro +@show+ th·ª© nh·∫•t ƒë√£ cho th·∫•y bi·∫øn ƒë·ªãa ph∆∞∆°ng +x+, bi·∫øn to√†n c·ª•c +y+ v√† bi·∫øn ƒë·ªãa ph∆∞∆°ng ch∆∞a ƒë·ªãnh nghƒ©a +z+. C√°c bi·∫øn to√†n c·ª•c ƒë·ªÅu kh√¥ng h·ªÅ b·ªã ƒë·ªông ƒë·∫øn.


==== Kh·ªëi +do+

Trong <<reading_and_writing>> ta ƒë√£ ph·∫£i ƒë√≥ng file l·∫°i sau khi ghi xong. C√≥ th·ªÉ th·ª±c hi·ªán ƒëi·ªÅu n√†y m·ªôt c√°ch t·ª± ƒë·ªông b·∫±ng c√°ch d√πng _kh·ªëi do_:
(((do)))((("keyword", "do", see="do")))

[source,@julia-repl-test chap19]
----
julia> data = "ƒê√¢y l√† h√†ng ph√™n d·∫≠u,\nbi·ªÉu t∆∞·ª£ng v√πng ƒë·∫•t c·ªßa ta.\n"
"ƒê√¢y l√† h√†ng ph√™n d·∫≠u,\nbi·ªÉu t∆∞·ª£ng v√πng ƒë·∫•t c·ªßa ta.\n"
julia> open("output.txt", "w") do fout
           write(fout, data)
       end
48
----

·ªû v√≠ d·ª• n√†y, +fout+ l√† d√≤ng file d√πng l√†m ƒë·∫ßu ra.

C√°ch vi·∫øt tr√™n c√≥ t√≠nh nƒÉng t∆∞∆°ng ƒë∆∞∆°ng v·ªõi

[source,@julia-repl-test chap19]
----
julia> f = fout -> begin
           write(fout, data)
       end
#3 (generic function with 1 method)
julia> open(f, "output.txt", "w")
48
----

H√†m khuy·∫øt danh ƒë∆∞·ª£c d√πng l√†m ƒë·ªëi s·ªë th·ª© nh·∫•t c·ªßa h√†m +open+:
(((open)))

[source,julia]
----
function open(f::Function, args...)
    io = open(args...)
    try
        f(io)
    finally
        close(io)
    end
end
----

Kh·ªëi +do+ c√≥ th·ªÉ ‚Äún·∫Øm‚Äù ƒë∆∞·ª£c c√°c bi·∫øn t·ª´ ph·∫°m vi bao tr√πm n√≥. Ch·∫≥ng h·∫°n, ·ªü v√≠ d·ª• tr√™n ta ƒë√£ n·∫Øm ƒë∆∞·ª£c bi·∫øn +data+ c·ªßa +open pass:[...] do+ t·ª´ ph·∫°m vi b√™n ngo√†i.


=== Lu·ªìng ƒëi·ªÅu khi·ªÉn

==== To√°n t·ª≠ ba ng√¥i

_To√°n t·ª≠ ba ng√¥i_, +?:+, l√† m·ªôt d·∫°ng kh√°c c·ªßa c√¢u l·ªánh +if-elseif+ ƒë∆∞·ª£c d√πng khi b·∫°n c·∫ßn l·ª±a ch·ªçn gi·ªØa c√°c gi√° tr·ªã bi·ªÉu th·ª©c ƒë∆°n.
(((?:)))((("operator", "Base", "?:", see="?:")))((("ternary operator", see="?:")))

[source,@julia-repl-test]
----
julia> a = 150
150
julia> a % 2 == 0 ? println("even") : println("odd")
even
----

Bi·ªÉu th·ª©c tr∆∞·ªõc d·∫•u +?+ l√† m·ªôt bi·ªÉu th·ª©c ƒëi·ªÅu ki·ªán. N·∫øu ƒëi·ªÅu ki·ªán n√†y l√† +true+, th√¨ ta s·∫Ω ∆∞·ªõc l∆∞·ª£ng bi·ªÉu th·ª©c tr∆∞·ªõc d·∫•u +:+, c√≤n kh√¥ng th√¨ s·∫Ω ∆∞·ªõc l∆∞·ª£ng bi·ªÉu th·ª©c sau d·∫•u +:+.

==== ∆Ø·ªõc l∆∞·ª£ng ƒëo·∫£n m·∫°ch

C√°c to√°n t·ª≠ +&&+ and +||+ ƒë·ªÅu th·ª±c hi·ªán _∆∞·ªõc l∆∞·ª£ng ƒëo·∫£n m·∫°ch_: m·ªôt ƒë·ªëi s·ªë ti·∫øp theo ch·ªâ ƒë∆∞·ª£c ∆∞·ªõc l∆∞·ª£ng khi ta c·∫ßn ph·∫£i x√°c ƒë·ªãnh gi√° tr·ªã cu·ªëi c√πng.
(((&&)))(((||)))(((∆∞·ªõc l∆∞·ª£ng ƒëo·∫£n m·∫°ch)))

Ch·∫≥ng h·∫°n, m·ªôt h√†m t√≠nh giai th·ª´a theo c√°ch ƒë·ªá quy c√≥ th·ªÉ ƒë∆∞·ª£c ƒë·ªãnh nghƒ©a nh∆∞ sau:
(((fact)))

[source,@julia-setup]
----
function fact(n::Integer)
    n >= 0 || error("n ph·∫£i l√† s·ªë kh√¥ng √¢m")
    n == 0 && return 1
    n * fact(n-1)
end
----

==== T√°c v·ª• (hay coroutine)

_T√°c v·ª•_ l√† m·ªôt c·∫•u tr√∫c ƒëi·ªÅu khi·ªÉn c√≥ th·ªÉ h·ª£p t√°c truy·ªÅn s·ª± ƒëi·ªÅu khi·ªÉn m√† kh√¥ng ph·∫£i tr·∫£ l·∫°i. Trong Julia, ta c√≥ th·ªÉ th·ª±c hi·ªán t√°c v·ª• nh∆∞ m·ªôt h√†m v·ªõi ƒë·ªëi s·ªë th·ª© nh·∫•t l√† m·ªôt ƒë·ªëi t∆∞·ª£ng +Channel+. M·ªôt channel ("k√™nh") ƒë∆∞·ª£c d√πng ƒë·ªÉ truy·ªÅn gi√° tr·ªã t·ª´ h√†m ƒë·∫øn m√£ l·ªánh g·ªçi n√≥.

B·∫±ng m·ªôt t√°c v·ª•, ta c√≥ th·ªÉ ph√°t sinh d√£y Fibonnaci.
(((t√°c v·ª•)))(((Channel)))((("type", "Base", "Channel", see="Channel")))(((put!)))((("function", "Base", "put!", see="put!")))

[source,@julia-setup chap19]
----
function fib(c::Channel)
    a = 0
    b = 1
    put!(c, a)
    while true
        put!(c, b)
        (a, b) = (b, a+b)
    end
end
----

+put!+ l∆∞u c√°c gi√° tr·ªã trong m·ªôt ƒë·ªëi t∆∞·ª£ng k√™nh c√≤n +take!+ ƒë·ªçc c√°c gi√° tr·ªã t·ª´ n√≥:
(((take!)))((("function", "Base", "take!", see="take!")))

[source,@julia-repl-test chap19]
----
julia> fib_gen = Channel(fib);

julia> take!(fib_gen)
0
julia> take!(fib_gen)
1
julia> take!(fib_gen)
1
julia> take!(fib_gen)
2
julia> take!(fib_gen)
3
----

Ph∆∞∆°ng th·ª©c d·ª±ng (constructor) +Channel+ t·∫°o n√™n t√°c v·ª•. H√†m +fib+ b·ªã treo l·∫°i m·ªói l·∫ßn g·ªçi ƒë·∫øn +put!+ v√† s·∫Ω h·ªìi ph·ª•c sau +take!+. ƒê·ªÉ ƒë·∫°t hi·ªáu nƒÉng t·ªët, ta nh·ªìi v√†o ƒë·ªëi t∆∞·ª£ng k√™nh v√†i gi√° tr·ªã c·ªßa d√£y trong t·ª´ng chu k√¨ treo/h·ªìi ph·ª•c.

Ta c≈©ng c√≥ th·ªÉ d√πng m·ªôt ƒë·ªëi t∆∞·ª£ng k√™nh l√†m b·ªô l·∫∑p:

[source,@julia-repl-test chap19]
----
julia> for val in Channel(fib)
           print(val, " ")
           val > 20 && break
       end
0 1 1 2 3 5 8 13 21
----


=== Ki·ªÉu d·ªØ li·ªáu

==== C√°c ki·ªÉu s∆° c·∫•p

Ta g·ªçi ki·ªÉu d·ªØ li·ªáu c·ª• th·ªÉ ch·ª©a nh·ªØng bit b·ªô nh·ªõ m√°y t√≠nh l√† _ki·ªÉu s∆° c·∫•p_. Kh√¥ng nh∆∞ nhi·ªÅu ng√¥n ng·ªØ kh√°c, trong Julia b·∫°n c√≥ th·ªÉ t·ª± ƒë·ªãnh nghƒ©a ra ki·ªÉu s∆° c·∫•p. C√°c ki·ªÉu s∆° c·∫•p chu·∫©n c≈©ng ƒë∆∞·ª£c ƒë·ªãnh nghƒ©a theo c√°ch n√†y:
(((ki·ªÉu s∆° c·∫•p)))((("t·ª´ kh√≥a", "ki·ªÉu s∆° c·∫•p", see="ki·ªÉu s∆° c·∫•p")))

[source,julia]
----
primitive type Float64 <: AbstractFloat 64 end
primitive type Bool <: Integer 8 end
primitive type Char <: AbstractChar 32 end
primitive type Int64 <: Signed 64 end
----

S·ªë ghi trong c√°c c√¢u l·ªánh s·∫Ω quy ƒë·ªãnh xem c·∫ßn bao nhi√™u bit.

V√≠ d·ª• ti·∫øp theo t·∫°o n√™n m·ªôt ki·ªÉu s∆° c·∫•p +Byte+ c√πng m·ªôt ph∆∞∆°ng th·ª©c d·ª±ng constructor:
(((Byte)))((("type", "programmer-defined", "Byte", see="Byte")))

[source,@julia-repl-test]
----
julia> primitive type Byte 8 end

julia> Byte(val::UInt8) = reinterpret(Byte, val)
Byte
julia> b = Byte(0x01)
Byte(0x01)
----

H√†m +reinterpret+ ƒë∆∞·ª£c d√πng ƒë·ªÉ l∆∞u gi·ªØ c√°c bit c·ªßa m·ªôt s·ªë nguy√™n kh√¥ng d·∫•u v·ªõi 8 bit (+UInt8+) v√†o trong ki·ªÉu byte.
(((reinterpret)))((("function", "Base", "reinterpret", see="reinterpret")))(((UInt8)))((("type", "Base", "UInt8", see="UInt8")))

==== Ki·ªÉu tham s·ªë

H·ªá th·ªëng ki·ªÉu Julia c√≥ t√≠nh _tham s·ªë_, nghƒ©a l√† c√°c ki·ªÉu c≈©ng c√≥ th·ªÉ c√≥ tham s·ªë.

C√°c tham s·ªë ki·ªÉu s·∫Ω ƒë∆∞·ª£c gi·ªõi thi·ªáu sau t√™n ki·ªÉu, trong c·∫∑p ngo·∫∑c nh·ªçn:
(((ngo·∫∑c nh·ªçn)))

[source,@julia-setup chap19]
----
struct Point{T<:Real}
    x::T
    y::T
end
----

M√£ l·ªánh tr√™n ƒë·ªãnh nghƒ©a m·ªôt ki·ªÉu tham s·ªë, +Point{T<:Real}+, trong ƒë√≥ ch·ª©a hai "t·ªça ƒë·ªô" ki·ªÉu +T+, v·ªën c√≥ th·ªÉ nh·∫≠n b·∫•t k√¨ ki·ªÉu n√†o mi·ªÖn l√† thu·ªôc ki·ªÉu s·ªë +Real+.

[source,@julia-repl-test chap19]
----
julia> Point(0.0, 0.0)
Point{Float64}(0.0, 0.0)
----

Ngo√†i c√°c ki·ªÉu ph·ª©c h·ª£p, c√°c ki·ªÉu tr·ª´u t∆∞·ª£ng v√† ki·ªÉu s∆° c·∫•p c≈©ng c√≥ th·ªÉ ch·ª©a tham s·ªë ki·ªÉu.

[TIP]
====
ƒê·ªÉ ƒë·∫°t hi·ªáu nƒÉng t√≠nh to√°n, r·∫•t c·∫ßn √°p d·ª•ng ki·ªÉu s∆° c·∫•p cho c√°c tr∆∞·ªùng c·ªßa m·ªôt c·∫•u tr√∫c (struct). V√¨ v·∫≠y, ki·ªÉu +Point+ l√†m theo c√°ch n√†y s·∫Ω r·∫•t nhanh v√† linh ho·∫°t.
====

==== H·ª£p ki·ªÉu

_H·ª£p ki·ªÉu_ l√† m·ªôt ki·ªÉu tham s·ªë tr·ª´u t∆∞·ª£ng c√≥ th·ªÉ ƒë√≥ng vai tr√≤ b·∫•t k√¨ ki·ªÉu tham s·ªë n√†o c·ªßa n√≥:
(((h·ª£p ki·ªÉu)))(((Union)))((("type", "Base", "Union", see="Union")))

[source,@julia-repl-test]
----
julia> IntOrString = Union{Int64, String}
Union{Int64, String}
julia> 150 :: IntOrString
150
julia> "Julia" :: IntOrString
"Julia"
----

H·ª£p ki·ªÉu c√≥ ·ªü b√™n trong h·∫ßu h·∫øt c√°c ng√¥n ng·ªØ m√°y t√≠nh ƒë·ªÉ gi√∫p suy lu·∫≠n ki·ªÉu. Tuy nhi√™n, Julia l·∫°i ph∆°i l·ªô t√≠nh nƒÉng n√†y cho ng∆∞·ªùi d√πng v√¨ khi h·ª£p ki·ªÉu ch·ªâ c√≥ r·∫•t √≠t ki·ªÉu th√¨ c√≥ th·ªÉ t·∫°o m√£ l·ªánh r·∫•t hi·ªáu qu·∫£. T√≠nh nƒÉn n√†y gi√∫p l·∫≠p tr√¨nh vi√™n Julia c√≥ ƒë∆∞·ª£c s·ª± linh ho·∫°t l·ªõn ƒë·ªÉ ki·ªÉm so√°t ƒëa ph∆∞∆°ng th·ª©c.

=== Methods

==== Parametric Methods

Method definitions can also have type parameters qualifying their signature:
(((signature)))

[source,@julia-repl-test chap19]
----
julia> isintpoint(p::Point{T}) where {T} = (T === Int64)
isintpoint (generic function with 1 method)
julia> p = Point(1, 2)
Point{Int64}(1, 2)
julia> isintpoint(p)
true
----

==== Function-like Objects

Any arbitrary Julia object can be made ‚Äúcallable‚Äù. Such ‚Äúcallable‚Äù objects are sometimes called _functors_.
(((functor)))

[source,@julia-setup chap19]
----
struct Polynomial{R}
    coeff::Vector{R}
end

function (p::Polynomial)(x)
    val = p.coeff[end]
    for coeff in p.coeff[end-1:-1:1]
        val = val * x + coeff
    end
    val
end
----

To evaluate the polynomial, we simply have to call it:

[source,@julia-repl-test chap19]
----
julia> p = Polynomial([1,10,100])
Polynomial{Int64}([1, 10, 100])
julia> p(3)
931
----

=== Constructors

Parametric types can be explicitly or implicitly constructed:

[source,@julia-repl-test chap19]
----
julia> Point(1,2)         # implicit T
Point{Int64}(1, 2)
julia> Point{Int64}(1, 2) # explicit T
Point{Int64}(1, 2)
julia> Point(1,2.5)       # implicit T
ERROR: MethodError: no method matching Point(::Int64, ::Float64)
----

Default inner and outer constructors are generated for each +T+:
(((constructor)))

[source,julia]
----
struct Point{T<:Real}
    x::T
    y::T
    Point{T}(x,y) where {T<:Real} = new(x,y)
end

Point(x::T, y::T) where {T<:Real} = Point{T}(x,y);
----

and both +x+ and +y+ have to be of the same type.

When +x+ and +y+ have a different type, the following outer constructor can be defined:

[source,@julia-setup chap19]
----
Point(x::Real, y::Real) = Point(promote(x,y)...);
----

The +promote+ function is detailed in <<promotion>>.
(((promote)))((("function", "Base", "promote", see="promote")))

=== Conversion and Promotion

Julia has a system for promoting arguments to a common type. This is not done automatically but can be easily extended.

==== Conversion

A value can be converted from one type to another:
(((conversion)))(((convert)))((("function", "Base", "convert", see="convert")))

[source,@julia-repl-test]
----
julia> x = 12
12
julia> typeof(x)
Int64
julia> convert(UInt8, x)
0x0c
julia> typeof(ans)
UInt8
----

We can add our own +convert+ methods:
[source,@julia-repl-test chap19]
----
julia> Base.convert(::Type{Point{T}}, x::Array{T, 1}) where {T<:Real} = Point(x...)

julia> convert(Point{Int64}, [1, 2])
Point{Int64}(1, 2)
----

[[promotion]]
==== Promotion

_Promotion_ is the conversion of values of mixed types to a single common type:
(((promotion)))(((promote)))

[source,@julia-repl-test]
----
julia> promote(1, 2.5, 3)
(1.0, 2.5, 3.0)
----

Methods for the +promote+ function are normally not directly defined, but the auxiliary function +promote_rule+ is used to specify the rules for promotion:
(((promote_rule)))((("function", "Base", "promote_rule", see="promote_rule")))

[source,julia]
----
promote_rule(::Type{Float64}, ::Type{Int32}) = Float64
----

=== Metaprogramming

Julia code can be represented as a data structure of the language itself. This allows a program to transform and generate its own code. 

==== Expressions

Every Julia program starts as a string:

[source,@julia-repl-test chap19]
----
julia> prog = "1 + 2"
"1 + 2"
----

The next step is to parse each string into an object called an _expression_, represented by the Julia type +Expr+:
(((expression)))(((Expr)))((("type", "Base", "Expr", see="Expr")))(((parse)))((("function", "Meta", "parse", see="parse")))

[source,@julia-repl-test chap19]
----
julia> ex = Meta.parse(prog)
:(1 + 2)
julia> typeof(ex)
Expr
julia> dump(ex)
Expr
  head: Symbol call
  args: Array{Any}((3,))
    1: Symbol +
    2: Int64 1
    3: Int64 2
----

The +dump+ function displays expr objects with annotations.
(((dump)))

Expressions can be constructed directly by prefixing with +:+ inside parentheses or using a quote block
(((:)))(((quote)))((("keyword", "quote", see="quote")))

[source,@julia-repl-test chap19]
----
julia> ex = quote
           1 + 2
       end;
----

==== +eval+

Julia can evaluate an expression object using +eval+:
(((eval)))((("function", "Core", "eval", see="eval")))

[source,@julia-eval chap19]
----
import Base.eval
----

[source,@julia-repl-test chap19]
----
julia> eval(ex)
3
----

Every module has its own +eval+ function that evaluates expressions in its scope.

[WARNING]
====
When you are using a lot of calls to the function +eval+, often this means that something is wrong. +eval+ is considered ‚Äúevil‚Äù.
====

==== Macros

Macros can include generated code in a program. A _macro_ maps a tuple of +Expr+ objects directly to a compiled expression:
(((macro)))

Here is a simple macro:
(((@containervariable)))((("macro", "programmer-defined", "@containervariable", see="@containervariable")))

[source,@julia-setup chap19]
----
macro containervariable(container, element)
    return esc(:($(Symbol(container,element)) = $container[$element]))
end
----

Macros are called by prefixing their name with the +@+ (at-sign). The macro call +@containervariable letters 1+ is replaced by:
(((@)))

[source,julia]
----
:(letters1 = letters[1])
----

+@macroexpand @containervariable letters 1+  returns this expression which is extremely useful for debugging.
(((@macroexpand)))((("macro", "Base", "@macroexpand", see="@macroexpand")))

This example illustrates how a macro can access the name of its arguments, something a function can‚Äôt do. The return expression needs to be ‚Äúescaped‚Äù with +esc+ because it has to be resolved in the macro call environment.
(((esc)))((("function", "Base", "esc", see="esc")))

[NOTE]
====
Why macros?

Macros generate and include fragments of customized code during parse time, thus _before_ the full program is run.
====

==== Generated Functions

The macro +@generated+ creates specialized code for methods depending on the types of the arguments:
(((generated functions)))(((@generated)))((("macro", "Base", "@generated", see="@generated")))

[source,@julia-setup chap19]
----
@generated function square(x)
    println(x)
    :(x * x)
end
----

The body returns a quoted expression like a macro.

For the caller, the _generated function_ behaves as a regular function:

[source,@julia-repl-test chap19]
----
julia> x = square(2); # note: output is from println() statement in the body
Int64
julia> x              # now we print x
4
julia> y = square("spam");
String
julia> y
"spamspam"
----

=== Missing Values

_Missing values_ can be represented via the +missing+ object, which is the singleton instance of the type +Missing+.
(((missing values)))(((missing)))(((Missing)))((("type", "Base", "Missing", see="Missing")))

Arrays can contain missing values:

[source,@julia-repl-test chap19]
----
julia> a = [1, missing]
2-element Array{Union{Missing, Int64},1}:
 1
  missing
----

The element type of such an array is +Union{Missing, T}+, with +T+ the type of the non-missing values.

Reduction functions return +missing+ when called on arrays which contain missing values

[source,@julia-repl-test chap19]
----
julia> sum(a)
missing
----

In this situation, use the +skipmissing+ function to skip missing values:
(((skipmissing)))((("function", "Base", "skipmissing", see="skipmissing")))

[source,@julia-repl-test chap19]
----
julia> sum(skipmissing([1, missing]))
1
----


=== Calling C and Fortran Code

A lot of code is written in C or Fortran. Reusing tested code is often better than writing your own version of an algorithm. Julia can call directly existing C or Fortran libraries using the +ccall+ syntax.
(((ccall)))((("function", "Base", "ccall", see="ccall")))

In <<databases>> we introduced a Julia interface to the GDBM library of database functions. The library is written in C. To close the database a function call to +close(db)+ has to be made:

[source,julia]
----
Base.close(dbm::DBM) = gdbm_close(dbm.handle)

function gdbm_close(handle::Ptr{Cvoid})
    ccall((:gdbm_close, "libgdbm"), Cvoid, (Ptr{Cvoid},), handle)
end
----

A dbm object has a field +handle+ of +Ptr{Cvoid}+ type. This field holds a C pointer that refers to the database. To close the database the C function +gdbm_close+ has to be called having as only argument the C pointer pointing to the database and no return value. Julia does this directly with the +ccall+ function having as arguments:
(((Ptr)))((("type", "Base", "Ptr", see="Ptr")))

* a tuple consisting of a symbol holding the name of the function we want to call: +:gdbm_close+ and the shared library specified as a string: +"libgdm"+,

* the return type: +Cvoid+,

* a tuple of argument types: +(Ptr{Cvoid},)+ and

* the argument values: +handle+.

The complete mapping of the GDBM library can be found as an example in the ThinkJulia sources.

=== Glossary

closure::
Function that captures variables from its defining scope.
(((closure)))

let block::
Block allocating new variable bindings.
(((let block)))

anonymous function::
Function defined without being given a name.
(((anonymous function)))

named tuple::
Tuple with named components.
(((named tuple)))

keyword arguments::
Arguments identified by name instead of only by position.
(((keyword arguments)))

do block::
Syntax construction used to define and call an anonymous function which looks like a normal code block.
(((do block)))

ternary operator::
Control flow operator taking three operands to specify a condition, an expression to be executed when the condition yields +true+ and an expression to be executed when the condition yields +false+.
(((ternary operator)))

short-circuit evaluation::
Evaluation of a boolean operator for which the second argument is executed or evaluated only if the first argument does not suffice to determine the value of the expression.
(((short-circuit evaluation)))

task (aka coroutine)::
Control flow feature that allows computations to be suspended and resumed in a flexible manner.
(((task)))

primitive type::
Concrete type whose data consists of plain old bits.
(((primitive type)))

type union::
Type which includes as objects all instances of any of its type parameters.
(((type union)))

parametric type::
Type that is parameterized.
(((parametric type)))

functor::
Object with an associated method, so that it is callable.
(((functor)))

conversion::
Conversion allows to convert a value from one type to another.
(((conversion)))

promotion::
Converting values of mixed types to a single common type.
(((promotion)))

expression::
Julia type that holds a language construct.
(((expression)))

macro::
Way to include generated code in the final body of a program.
(((macro)))

generated functions::
Functions capable of generating specialized code depending on the types of the arguments.
(((generated functions)))

missing values::
Instances that represent data points with no value.
(((missing values)))
